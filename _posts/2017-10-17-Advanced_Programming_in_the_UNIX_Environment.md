#---
layout: post
title: "《UNIX环境高级编程》读书笔记"
categories: 笔记
---
* content
{:toc}
《UNIX环境高级编程》读书笔记





# 第一章 UNIX基础知识
- shell：命令行解释器，是一个特殊的应用程序，为运行其他的应用程序提供接口
- 只有'/'和' '
- 不带缓冲的I/O：open、read、write、lseek和close，这些函数都使用文件描述符
- 标准I/O函数为那些不带缓冲的I/O函数提供了一个带缓冲的接口,这样我们就不必担心最佳缓冲区的大小
- 使用long保存getpid的返回值可以提高可移植性
- fgets返回的每一行都是以换行符结束的
- fork对父进程返回子进程的pid(非负整数)，对子进程返回0
- 一个进程内的所有线程共享同一个地址空间、文件描述符、栈以及与进程相关的属性
- fork、exec和waitpid是对进程管理的一套函数，注意不是线程
- 当UNIX系统函数出错时，通常会返回一个负值，并设置errno为特定信息的值；对于返回指针的函数出错时会返回NULL
- 使用errno的规则
    - 如果没有出错，其值不会被清除。因此只有在函数返回值指明出错时才检查其值
    - 任何函数都不会将errno的值置为0
- `char *strerror(int errnum)`:返回errnum对应的错误信息
- `void perror(char *msg)`:在标准错误上输出：msg+冒号+空格+错误信息+换行
- 出错恢复
    - 致命性错误：记录日志然后退出，什么也恢复不了
    - 非致命性错误：与资源相关时，典型的操作是等待一段时间重试
- 信号用于通知进程发生了某种情况
    - 处理信号的方式
        - 忽略信号,不推荐使用这种方式
	- 按照系统默认的方式处理
	- 提供一个函数，信号发生时调用该函数,不能够捕获SIGKILL和SIGSTOP
    - 产生信号的方式
        - 通过中断键和退出键
	- 通过kill发送信号，注意只有超级用户和进程所有者才可以给进程发送信号
- 时间值
    - 日历时间使用的是UTC，进程时间使用的是时钟滴答
    - 为一个进程维护了三个时间值
        - 时钟时间：进程运行的时间总量
	- 用户CPU时间：执行用户指令的时间总量
	- 系统CPU时间：执行系统调用的时间总量
    - 在shell中通过time命令可以度量进程的三个时间值
- 系统调用和库函数
    - UNIX为每个系统调用在libc中设置一个具有同样名字的函数

# 第二章 UNIX标准及实现
- ANSI是ISO中代表美国的成员，ANSI89被采纳为ISO90
- ISO C：定义C程序设计语言的语法和语义，还定义了其标准库
- IEEE POSIX：规范可移植操作系统接口，并不区分系统调用和库函数，包含了ISO C
- Single UNIX Specification(SUS):可以看成是POSIX.1的超集，定义了遵循XSI实现必须支持POSIX.1的可选部分，只有遵循了XSI实现才能称为UNIX系统
- UNIX移植的限制：编译时限制、运行时限制
    - 编译时限制通过头文件解决 
    - 与文件或目录无关的限制通过sysconf函数
    - 与文件或目录有关的限制通过pathconf和fpathconf函数
- ISO C的所有编译时限制都在头文件limits.h中
    - 可以通过查看该文件判断系统是否提供带符号和无符号的字符值
    - 对于浮点数的限制定义在float.h中
    - POSIX.1对ISO C的限制进行了扩展
- POSIX限制:某些可能定义在limits.h头文件中，其余的则按具体条件可定义可不定义
- XSI限制
- sysconf、pathconf和fpathconf
    - 如果name参数不是一个合法的变量，3个函数都会返回-1，并把errno置为EINVAL
    - 有些name会返回一个变量值(>=0)或者提示该值是不确定的。不确定的值通过返回-1来体现而不改变errno的值
    - 以\_SC开头的name参数适用于sysconf，以\_PC开头的name参数适用与pathconf和fpathconf
- 不确定运行时限制的解决思路：先假定一个值然后根据具体的使用场景进行处理
- 判断是否支持POSIX.1的可选选项
    - 编译时选项定义在unistd.h中
    - 与文件或目录无关的运行时选项用sysconf
    - 与文件或目录有关的运行时选项用pathconf或fpathconf
- 选项可能的平台支持状态
    - 如果符号常量没有定义或者定义为-1，那么平台不支持该选项
    - 如果符号常量定义为大于0，那么平台支持该选项
    - 如果符号常量定义为0，那么需要调用sysconf、pathconf和fpathconf来判断是否支持该选项，如果这些调用返回-1则表示不支持该选项
- 功能测试宏：在POSIX.1和XSI实现的头文件中加入了很多非标准的定义，通过定义\_POSIX\_C\_SOURCE和\_XOPEN\_SOURCE功能测试宏来排除任何实现专有的定义
- 基本系统数据类型：使用这些类型就不再需要考虑因为系统不同而带来的变化，如size\_t
- 标准之间的冲突：ISO C的clock()和POSIX.1的times()的返回值单位不同；ISO C的函数没有像POSIX.1那么严格，所以POSIX.1要求某些函数有不同的实现

# 第三章 文件I/O
- 不带缓冲的I/O指的是read和write都只是调用内核中的一个系统调用,这些I/O函数都不是ISO C的一部分，但是POSIX.1和SUS的组成部分
- 文件描述符
    - 是一个非负整数
    - 0对应标准输入，1对应标准输出，2对应标准错误；为了提高可读性，应该使用unistd.h中定义的STDIN\_FILENO,STDOUT\_FILENO,STDERR\_FILENO
- 函数open和openat
    - 由open和openat返回的文件描述符一定是最小未用的，比如可以先关闭标准输入0，再打开一个文件，这样就将文件作为标准输入使用了
    - openat函数的使用
        - 如果path参数指定的是绝对路径，那么fd参数被忽略，这时跟open函数一样
	- 如果path参数指定的是相对路径，那么fd参数指明了相对路径在文件系统中的开始位置，fd参数通过打开一个目录获得
	- 如果path参数制定的是相对路径，并且此时fd参数是AT\_FDCWD特殊值，那么相对路径从当前的工作目录开始
    - openat函数解决的问题
        - 让不同的线程很方便地拥有不同的工作目录
	- 避免TOCTTOU错误：如果有两个基于文件的调用，其中第二个调用依赖于第一个调用的结果，因为两个调用之间不是原子的，在两个调用之间文件可能发生了改变，导致程序最终的结果是错误的
    - 文件名和路径名的截断：若\_POSIX\_NO\_TRUNC有效，则在整个路径名超过PATH\_MAX或路径名中的任意文件名超过NAME\_MAX时出错返回，并将errno设置为ENAMETOOLONG
- 函数creat
    - 相当于open(path, O\_WRONLY|O\_CREAT|O\_TRUNC, mode)
    - 因为早期的UNIX版本open并不能创建文件，所以才有这个函数
- 函数close
    - 关闭一个文件时还会释放该进程加在文件上的记录锁
    - 当进程终止时，内核会自动关闭它打开的所有文件，因此很多程序都没有显式调用close函数
- 函数lseek
    - 当打开一个文件时，除非指定O\_APPEND,否则文件偏移量设置为0
    - lseek(fd, 0, SEEK\_CUR):可以返回当前的文件偏移量，也可以用于测试文件是否可以设置偏移量(如果文件指向的是管道，FIFO或者网络套接字，lseek将返回-1，并将errno设置为ESPIPE)
    - lseek前面的l表示的是long长整形，在引入off\_t之前,lseek的返回值是long类型
    - 对于普通文件来说，偏移量总是非负数，但是对于某些设备文件来说偏移量可以是负数，因此应该通过判断lseek的返回值是否等于-1来判断lseek是否成功调用
    - 文件的偏移量可以大于当前文件的长度，如果此时写文件将产生一块空洞。位于文件中但没有写过的字节都读为0。文件中的空洞虽然会影响文件的大小但是不占用实际的磁盘空间
    - off\_t支持32bit和64bit，可以通过getconf指定c99使用的标志
- 函数read
    - 返回实际读取到的字节数，如果到文件尾返回0；读取失败返回-1
- 函数write
    - 文件偏移量增加实际写的字节数
- I/O效率
    - 系统CPU时间的最小值差不多出现在BUFFSIZE为磁盘块的大小，继续增大BUFFSIZE几乎不影响该值
    - 大多数文件系统采用了预读技术，所以小缓冲区的时钟时间与拥有大缓冲区的时钟时间几乎一样
- 文件共享
    - 内核使用三种结构表示打开的文件
        - 每个进程包含一张打开的*文件描述符表*
	    - 文件描述符表项由文件描述符标志和一个指向文件表项的指针组成
	- 内核为所有打开的文件维护一张*文件表*
	    - 文件表项由文件状态标志、当前文件偏移量和指向该文件v节点表项的指针组成
	- 每个打开的文件都有一个*v节点*
	    - v节点表项包含了v节点信息和指向i节点的指针
    - 文件描述符标志和文件状态标志的作用范围不同
    - 使用dup和fork时会有多个文件描述符项指向同一个文件项
- 原子操作:由多步组成的一个操作，如果该操作原子地执行，则要么执行完所有步骤，要么一步也不执行
    - 追加到一个文件：在open文件时使用O\_APPEND标志，这样每次调用write写文件时就会原子地lseek到文件尾
    - 函数pread和pwrite:允许原子地定位并执行I/O
    - 创建一个文件:在open的flags中加入O\_CREAT和O\_EXCL表示如果文件不存在则创建文件，如果文件存在open调用失败
- 函数dup和dup2
    - int dup(int fd):返回的一定是最小可用的文件描述符
    - int dup2(int fd, int fd2):返回的是fd2指定的文件描述符，如果fd2是打开的则先将其关闭；如果fd等于fd2则直接返回fd2；
    - 这些函数返回的新文件描述符与原来的fd共享同一个文件表项
    - 新文件描述符的执行时关闭标志(FD\_CLOEXEC)总是由dup函数清除
    - dup2操作不完全等同于close和fcntl
        - dup2是原子操作，close和fcntl涉及到两个函数
	- dup2和fcntl有一些不同的error
- 函数sync、fsync和fdatasync
    - 内核中的延迟写：当我们向磁盘写入数据时，内核通常先将数据复制到缓冲区，然后排入写队列，晚些时候再写入磁盘
    - sync：将所有修改过的块缓冲区排入写队列然后返回，并不等待实际写磁盘操作结束
    - fsync：对指定的文件描述符起作用，等待实际写磁盘操作结束
    - fdatasync：与fsync类似，但是它只影响文件的数据部分，fsync还会同步更新文件的属性
    - 这三个函数和O\_SYNC同步标志与底层操作系统、文件系统有关
- 函数fcntl:如果失败所有命令都返回-1，成功则返回其他值
    - 复制一个已有的描述符(F\_DUPFD,F\_DUPFD\_CLOEXEC)
    - 获取/设置文件描述符标志(F\_GETFD,F\_SETFD),记住要防止丢失之前的设置值
    - 获取/设置文件状态标志(F\_GETFL,F\_SETFL)，记住要防止丢失之前的设置值
    - 获取/设置异步I/O所有权(F\_GETOWN,F\_SETOWN)
    - 获取/设置记录锁(F\_GETLK,F\_SETLK,F\_SETLKW)
- 函数ioctl
    - 使用ioctl通常还需要另外的设备专用头文件，终端I/O的ioctl命令在头文件termios.h中
- /dev/fd
    - open("/dev/fd/n", flags)相当于dup(n)，大多数系统会忽略open时指定的flags
    - 注意Linux实现的/dev/fd/n是指向底层物理文件的符号链接，其并不会忽略flags，例如它可能会被O\_TRUNC
    - /dev/fd主要由shell使用，例如作为命令行参数的"-"表示标准输入或标准输出

# 第四章 文件和目录

# 第五章 标准I/O库
- 标准I/O库处理很多细节，比如缓冲区的分配，以优化的块长度执行I/O等
- 流和FILE对象
    - 之前介绍的不带缓冲区的I/O函数是围绕文件描述符展开的，标准I/O库是围绕流(stream)展开的，当stdio打开一个文件时，已使一个流和一个文件相关联
    - 流的定向(stream's orientation)决定了所读所写的字符是单字节还是多字节
        - 当一个流被创建的时候是未定向的，若在未定向的流上使用一个多字节I/O函数则将流设置为宽定向；若使用单字节的I/O函数则将流设置为字节定向
	- 只有两个函数可以改变流的定向
	    - freopen:清除一个流的定向
	    - fwide:设置一个流的定向；不改变已定向流的方向；没有出错返回，只能通过检查errno的值判断有无出错
    - fopen返回一个FILE对象的指针，称之为文件指针
- stdin,stdout,stderr
    - 在头文件stdio.h中定义了对应于STDIN\_FILENO,STDOUT\_FILENO,STDERR\_FILENO的文件指针
- 缓冲
    - 标准I/O提供了三种缓冲机制
        - 全缓冲：在填满I/O缓冲区后才进行实际的I/O操作；缓冲区可由标准I/O自动冲洗(例如在缓冲区满时)也可调用fflush冲洗一个流；对驻留在磁盘上的文件通常使用全缓冲
	- 行缓冲：当在输入和输出中遇到换行符时，标准I/O库执行I/O操作；当流涉及终端时，通常采用行缓冲
	    - 当行缓冲区满时，即使没有遇到换行符也会进行I/O操作
	    - 通过标准I/O库从一个行缓冲的流(从内核请求需要数据)请求输入数据，也会冲洗行缓冲区
	- 不带缓冲：就像直接使用write函数。stderr通常是不带缓冲的
    - ISO C要求使用下列的缓冲特征
        - 当且仅当标准输入和标准输出并不指向交互式设备时，它们才是全缓冲的
	- 标准错误绝不会是全缓冲的
    - 因为ISO C的规定不是很清楚，很多系统默认使用下列类型的缓冲
        - 标准错误是不带缓冲的
	- 若是指向终端设备的流则是行缓冲的；否则是全缓冲的
    - 更改缓冲类型，下面的函数一定要在打开流之后才能调用，而且也应该在对流执行任何一个其他操作之前调用
        - setbuf:打开或者关闭缓冲机制，缓冲区的长度为BUFSIZ(定义在stdio.h中)；默认是全缓冲；为了关闭，将buf设置为NULL
	- setvbuf:精确地设置缓冲区，比如缓冲的类型、缓冲区的长度
	- 如果分配了自动变量类型的缓冲区，则在函数返回前需要关闭流
    - fflush强制冲洗一个流，将流所有未写的数据都传送到内核中；当fflush接收NULL时，会导致所有输出流被冲洗；标准没有定义fflush用于输入流的情况
- 打开流
    - fopen:打开给定路径的文件
    - freopen：在指定的文件指针上打开给定路径的文件，会关闭原来的文件并清除流定向；通常用于重定向stdin等
    - fdopen：使用一个已有的文件描述符打开流
    - 打开流的type参数：r、w、a、r+、w+、a+,每个参数都可以加上b区分是文本文件还是二进制文件，但是UNIX并不区分这两种文件
        - fdopen不能截断它为写打开的文件；追加写也不能够创建该文件
        - 如果有多个进程写同一个文件，应该以追加写的方式打开
	- 当以读写形式打开一个文件时(type中的+号)，有以下的限制：
	    - 如果中间没有插入fflush、fseek、fsetpos或rewind，那么输出后面不能直接跟随输入
	    - 如果中间没有插入fseek、fsetpos或rewind，那么输入后面不能直接跟随输出
	- 在w或a创建一个文件时，无法指定文件的访问权限位
    - fclose关闭流：在文件被关闭之前，冲洗缓冲中的输出数据，丢弃缓冲中的输入数据。如果标准I/O库为该流自动分配了一个缓冲区，则释放此缓冲区
        - 当进程正常终止时，所有打开的标准I/O流都被关闭
- 读和写流
    - 一旦打开了一个流，可在3中不同类型的非格式化I/O中进行选择
        - 每次一个字符的I/O
	    - 输入函数
	        - getc、fgetc和getchar
		- 函数getchar等同于getc(stdin),getc可被实现为宏，fgetc是一个函数
		- 成功返回下一个字符，不管是出错还是到达文件尾端，这三个函数都是返回EOF，需要通过以下函数检查
		    - ferror：为真时返回非0
		    - feof：为真时返回非0
		    - clearerr：清除两个标志
		- ungetc压送字符回流。读出字符顺序与回送字符顺序相反；ungetc会清除流的文件结束标志；只是写回到流缓冲区中
	    - 输出函数
	        - putchar等同于putc(c, stdout)，putc可被实现为宏，fputc是一个函数
		- 成功返回字符c，出错返回EOF
	- 每次一行的I/O：使用fgets和fputs
	    - 输入函数
	        - fgets：必须指定缓冲区长度n，并且返回的缓冲区一定是以null结尾的，意味着如果包括换行符在内的字符串长度超过了n-1，那么下一次还是会继续读取该行
		- gets：不推荐使用；不保留最后的换行符
		- 成功返回buf指针，不管是出错还是到达文件尾，都是返回NULL，处理方法同getc
	    - 输出函数
	        - fputs：将一个以null结尾的字符串输出，必须自己处理换行符
		- puts：将一个以null结尾的字符串输出到标准输出，会自动输出换行符
		- 成功返回非负值，出错返回EOF
	- 直接I/O：也称为二进制I/O，读或写某种数量的对象；使用fread和fwrite
- 标准I/O的效率(与不带缓冲区的I/O比较)
    - 系统CPU时间基本相同，这是因为标准I/O库已经为我们考虑好了最佳的缓冲区长度，因此对内核提出的读写请求数基本相同
    - fgets和fputs的速度接近于最优缓冲区长度的read和write
    - fgetc和fputc的速度要比BUFFSIZE=1时的read和write要快很多，两者进行的循环数差不多，当后者进行的系统调用要慢很多
    - stdio并不比直接使用read和write慢很多。对于复杂的应用主要的时间消耗在应用程序的各种处理上，而不是标准I/O例程上
- 二进制I/O
    - fread：返回读取的对象数，如果不等于nobj的值，需要通过ferror和feof查看是出错还是到了文件尾
    - fwrite：返回写入的对象数，如果不等于nobj的值，说明发生了错误
    - fread和fwrite在不同的环境中可能不能正常工作：
        - 对结构体的对齐要求不同
	- 多字节整数的大小端和浮点数的表示形式
	-解决方法是使用统一的规范
- 定位流
    - ftell、fseek和rewind
        - 偏移量类型是long
        - 对于二进制文件，文件当前位置是从文件起始位置开始度量，度量单位是字节。ISO C并不要求实现SEEK_END，UNIX支持SEEK_END
	- 对于文本文件，文件当前位置可能不以简单的字节偏移量来度量。为了定位一个文本文件，whence一定要是SEKK\_SET,而且offset只能有两种取值：0(后退到文件的起始位置)；或是ftell返回的值
	- rewind可以将一个流设置到起始位置
    - ftello和fseeko
        - 除了偏移量类型是off_t，其余和ftell和fseek相同
    - fgetpos和fsetpos
        - 是ISO C定义的，可以移植到非UNIX系统上
	- 可以通过fgetpos保存当前的位置，使用fsetpos回到保存的位置
- 格式化I/O
    - 输出
        - printf：标准输出
        - fprintf：输出到文件指针
        - dprintf：输出到文件描述符
        - sprintf：输出到缓冲区，但是要确保缓冲不要溢出，会在字符串的末尾自动加null，但是不计入返回值
        - snprintf：可以指定缓冲区大小，追加null，但是不计入返回值
        - 还有上面五种格式化输出的变体：vprintf等
    - 输入
        - scanf、fscanf和sscanf
	- 除了转换说明和空白字符外，格式化字符串中的其他字符必须与输入匹配，若有一个字符不匹配，停止后续处理，不再读入其他部分
	- vscanf、vfscanf和vsscanf
- 实现细节
    - fileno(FILE\*)：获得一个流对应的文件描述符；注意此函数不是ISO C的一部分
- 临时文件
    - ISO C标准，但SUSv4已弃用
        - tmpnam：返回一个临时的路径名；有调用次数限制TMP\_MAX；缓冲区的大小为L\_tmpnam;如果给定一个空的指针作为参数，那么将在静态缓冲区中存放路径名，作为返回值返回，下一次调用会覆盖该静态缓冲区
        - tmpfile：创建一个临时的二进制文件(wb+)，并返回其文件指针；在关闭文件或者程序结束时会自动删除文件
    - SUSv4支持
        - mkdtemp:创建一个临时目录
	- mkstemp:与tmpfile不同，创建的临时文件不会自动删除，需要手动unlink
	- 这两个函数都会修改参数template，因此要传入一个字符数组，例如`char *template="/tmp/XXXXXX";`是错误的，因为template是一个字符常量
    - 注意如果使用tmpnam获得一个临时路径名然后创建一个文件是不可取的，因为两者之间存在时间窗口，应该直接使用tmpfile或者mkstemp
- 内存流(标准I/O流)
    - `FILE *fmemopen(void *restrict buf, size_t size, const char *restrict type)`
        - 如果buf为NULL，当关闭流时会自动释放缓冲区
	- type的使用和标准的I/O有些许差别
	- 只有执行冲洗操作内容才会写入到缓冲区中，比如fflush和fseek
    - open\_memstream创建的流是面向字节的，open\_wmemstream是面向宽字节的
- 标准I/O的替代软件
    - 标准I/O的一个不足之处是效率不高，因为读数据时，需要将数据从内核复制到标准库缓冲区，从标准库缓冲区复制到用户缓冲区
    - 快速I/O库fio
    - sfio
    - ASI
    - uClibc(嵌入式系统)
- 小结
    - 标准I/O库使用了缓冲技术，正是因为它产生了很多问题、引起了许多混淆

# 第六章 系统数据文件和信息

# 第七章 进程环境
- `int main(int argc, char *argv[]);`
    - 链接器将一段启动例程添加到可执行文件的开头，启动例程从内核读取参数和环境变量，然后调用main函数
- 进程终止
    - 退出函数
        - exit和\_Exit是ISO C标准定义的
	- \_exit是POSIX.1定义的
	- \_Exit和\_exit会直接进入内核，但是exit会先调用各终止处理程序，然后关闭所有打开的流再进入内核,在现代exit实现中不会再关闭流了，因为在进程终止时内核会关闭进程打开的所有文件描述符
	- `exit(0)`和`return (0)`是等价的
    - 函数atexit
        - 注册终止处理程序，这些程序将由exit自动调用
	- 调用顺序与注册顺序相反，同一个函数注册多次可导致多次调用
	- POSIX.1规定如果程序调用了exec族的函数，将清除所有已注册的终止处理程序
    - 内核使程序执行的唯一方法是调用exec函数，进程自愿终止的方法是显式或者隐式(通过exit函数)调用\_exit或\_Exit
- 命令行参数
    - 通过exec函数传递命令行参数
    - ISO C和POSIX.1都要求argv[argc]为NULL
- 环境表:与参数表一样，每个程序都会接收到一张环境表
    - 通过环境指针`extern char **environ;`可以查看所有的环境变量
    - 通常使用getenv和putenv来访问特定的环境变量，而不是直接访问environ
- C程序存储空间布局:占用磁盘空间的只有正文段和初始化数据段，bss段不占用空间
    - 正文段：机器指令。可共享，只读
    - 初始化数据段：包含了程序中需要明确赋初值的变量
    - 未初始化数据段(bss段)：在程序开始执行之前，内核将此段中的数据初始化为0或者空指针
    - 堆：通常在堆中进行动态存储分配
    - 栈：存放自动变量以及每次函数调用所需保存的信息
- 共享库
    - 在所有进程都可引用的存储区保存这种库的一个副本，当第一次调用这个库时，通过动态链接的方法将程序与共享库相链接
    - 只需要在内存中保留一份库的副本，节约内存；可以很方便地升级库而不需要修改程序
- 存储空间的分配
    - malloc：分配给定字节数的内存，初始值不确定
    - void \*calloc(size\_t nobj, size\_t size)：为指定数量指定长度的对象分配内存，每个字节初始化为0
    - realloc：增加或减少以前分配区的长度
        - 当增加存储空间时，如果在该存储区后还有地址可以使用，则直接在进行扩充即可；否则重新分配一块大的存储区，将数据复制到新存储区中，返回新存储区的地址
	- 因为存储区可能会移动位置，因此不能够使任何指针指向存储区
	- 最后一个参数是存储区的新长度，不是新旧之间的长度差
    - 这三个函数返回的内存一定是适当对齐的，可以用于任何数据对象
    - 当包含了这些函数原型(stdlib.h)之后就不需要显式强制类型转换了
    - 通过free释放的空间通常保留在malloc池中而不返回给内核
    - 可能的致命性错误
        - 在动态分配的缓冲区前或后写可能会修改存储空间的管理信息、破坏其他动态分配的对象
        - 重复释放块
	- free释放的内存不是通过以上三个函数获得的
	- 忘记释放内存导致内存泄露
- 替代的存储空间分配程序
- 环境变量:我们能够影响的只是当前进程及其后生成和调用的子进程的环境，不能影响父进程的环境
    - UNIX内核并不使用环境变量，对这些变量的解释完全取决于应用程序
    - `char *getenv(const char *name)`:name对应的环境变量值
    - `int putenv(char *str)`:直接将str作为环境变量，注意str应该是分配在堆上的
    - `int setenv(const char *name, const char *value, int rwrite)`:与putenv相比，此函数需要重新分配存储空间给新的环境变量
    - `int unsetenv(const char *name)`:删除name对应的环境变量
- 函数setjmp和longjmp
    - goto不能够跨越函数，但这两个函数能够跨越函数进行跳转
    - `int setjmp(jmp_buf env)`:若直接调用返回时返回值为0；如果从longjmp返回时返回值为longjmp的参数val
    - `void longjmp(jmp_buf env, int val)`:env是setjmp时保存的信息；val是setjmp的返回值
    - 从longjmp返回后自动变量、寄存器变量的值是否回滚要“看情况”，所有的标准都说是不确定的
        - 存放在存储器中的变量不会回滚，在CPU和浮点寄存器中的变量则回滚到调用setjmp时的值
	- 无论编译器的优化等级，volatile、static和全局变量都存放在存储器中
    - 自动变量的潜在问题
        - 当声明自动变量的函数返回后，不能再引用这些自动变量
- 函数getrlimit和setrlimit
    - 每个进程都有一组资源限制，其中一些可以通过这两个函数进行查询和设置
    - 任何一个进程都可在硬限制值的范围内调节软限制值
    - 任何一个进程都可降低硬限制的值，对于普通用户来说这是不可逆的操作
    - 只有超级用户可以提高硬限制的值
    - 资源限制将由子进程继承，为了对用户的所有进程进行限制，应该将资源限制构造在shell中

# 第八章 进程控制
- 进程标识
    - 延迟复用算法使得新分配的PID不会是最近终止的PID
    - getpid:返回PID
    - getppid:返回父进程的PID
    - getuid:返回实际用户ID
    - geteuid:返回有效用户ID
    - getgid:返回实际用户组ID
    - getegid:返回有效用户组ID
- 函数fork
    - 对于子进程返回0，因为子进程可以通过getppid获得父进程的pid；对于父进程返回创建的子进程的pid，因为没有一个函数可以获得一个进程的所有子进程；
    - 因为执行fork之后子进程通常会执行exec装入新的程序，所有使用写时复制技术(COW)，如果父进程或者子进程修改数据，则只为修改的那块内存区域制作一个副本
    - fork之后是父进程还是子进程先执行这取决于内核的调度算法
    - strlen进行的是函数调用，sizeof是编译时计算
    - 父子进程每个相同的打开的文件描述符共享同一个文件表项
        - 如果父子进程同时写一个文件描述符，但是没有任何的同步，它们的输出就会混合在一起，但是这种操作不常见
	- 父进程等待子进程完成，这种情况无需对文件描述符做任何处理
	- 在fork之后，父子进程各自关闭它们不需要的文件描述符，这样就不会干扰到对方了
    - fork失败的主要原因：系统中有太多的进程了(此时系统出现了问题)；用户拥有的进程数超过了CHILD\_MAX
    - fork通常的用法：
        - 使得父子进程执行不同的代码，在网络服务进程中是很常见的
	- 进程希望执行另一个程序，例如shell
- 函数vfork
    - vfork用于创建一个新的进程，该进程的目的就是exec一个新的程序
    - 子进程运行于父进程的空间中，但是子进程的任何修改行为都会带来未知的结果
    - vfork保证子进程优先执行，在子进程调用了exec或exit后父进程才可能被调度运行
    - vfork还是会复制父进程的文件描述，但是区别于fork，其不会复制父进程的page table
- 函数exit
    - 5种正常终止
    - 3种异常终止
    - 不管进程是如何终止的，内核最后都会执行同一段代码，为进程关闭所有打开的文件描述符，释放它所使用的内存
    - 被终止进程通知其父进程
        - 正常终止：通过给三个exit函数传递参数或者是main函数的返回值，称为退出状态(exit status)
	- 异常终止：内核会产生一个终止状态(termination status)
	- 在调用\_exit时，退出状态会成为终止状态
	- 父进程可以使用wait或waitpid函数获得子进程的终止状态
    - 孤儿进程：当终止一个进程时，内核会检查当前所有活动的进程是否是该进程的子进程，如果是，那么这些进程会被init进程收养；注意不会被爷爷进程收养
    - 内核为每个终止子进程保存了一定量的信息，这些信息可供父进程调用wait或waitpid时查询；
    - 僵死进程：如果父进程没有对已经终止的子进程进行善后处理(获取子进程的相关信息、释放所占用的资源)，子进程就会成为僵死进程
- 函数wait和waitpid
    - 当一个进程终止时，内核就向其父进程发送SIGCHLD信号；系统默认的动作时忽略该信号
    - 调用wait和waitpid时会发生什么
        - 如果所有的子进程都在运行中，那么将阻塞父进程
	- 如果一个子进程在调用之前已经终止了，那么立即返回
	- 如果没有任何的子进程，那么调用出错返回
    - wait和waitpid的区别
        - wait会阻塞住父进程直到有一个子进程终止；waitpid可以指定不阻塞的选项
	- waitpid可以指定等待的进程；wait是对于所有的子进程
    - 在\<sys/wait.h\>中定义了查看终止状态的宏
    - 如果父进程不想要等待子进程终止又不想让子进程成为僵死进程，可以采用fork两次的方法，将孙子进程托付给systemd进程
- 函数waitid
    - 
